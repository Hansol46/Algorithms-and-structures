# Алгоритмы и стуктуры данных

## Теория

Сложность алгоритма в теории алгоритмов описывается с помощью формулы:_O(n)_, 
где _n_ - это кол-во операций, за который этот алгоритм приходит к нужному результату, всегда рассматривается наихудший сценарий.
Ссылка на полезнеёшую статью: https://habr.com/ru/articles/782608/

### Виды сложностей

1. _О(1)_ - константная сложность
При константной сложности вне зависимости от размера входных данных (n), время выполнения алгоритма остается постоянным и не зависит от объема данных.
Пример:
```
function getLastElement(arr) {
  return arr[arr.length - 1 ]
}
function addToArray(arr, el) {
  return arr.push(el);
}
```

2. _O(n)_ - линейная сложность
Оценка временной сложности O(n) означает, что время выполнения алгоритма растет линейно с увеличением размера входных данных.
пример:
```
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}
```

3. _O(logn)_ - логарифмическая сложность.
Алгоритм становится медленнее, но не линейно, а медленнее в соответствии с логарифмической функцией.
Пример: Бинарный поиск. В этом алгоритме на каждом шаге половина данных отсекается, и поиск продолжается в оставшейся половине. Это означает, что при увеличении размера входных данных вдвое, бинарный поиск требует всего одного дополнительного шага.
```
function binarySearch(arr, target) {
	let left = 0;
	let right = arr.length - 1;
  while (left &lt;= right) {
	  let mid = Math.floor((left + right) / 2);
	  if (arr[mid] === target) return mid; 
	  if (arr[mid] &lt; target) {
      left = mid + 1;
	  } else {
      right = mid - 1; // искать в левой половине
	  }
  }
  return -1; // элемент не найден
}
```

4. _O(n^2)_ - квадратичная
Время выполнения растет пропорционально квадрату размера входных данных
Пример: Это часто возникает в алгоритмах с вложенными циклами, когда каждый элемент первого списка обрабатывается с каждым элементом второго списка.

5. _O(n^3)_ - кубическая
Время выполнения алгоритма увеличивается кубически по размеру входных данных.
Пример: опять же по аналогии с квадратичной, 3 вложенных цикла.


6. _O(2^n)_ - экспоненциальная
Время выполнения алгоритма увеличивается экспоненциально по мере увеличения размера входных данных. Это часто встречается в алгоритмах, которые решают проблемы методом "разделяй и властвуй" или используют рекурсию без оптимизации.
Пример:
```
function fibonacci(n) {
	if (n === 1 || n === 2) return 1; 
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

7. O(n!) - факториальная сложность
Время выполнения алгоритма растет пропорционально факториалу размера входных данных. Факториал - это произведение всех положительных целых чисел от 1 до n.
Пример алгоритма с факториальной сложностью может быть перебор всех перестановок элементов массива.

### Дополнение
Игнорирование констант. В данном случае, даже если у нас есть 2n операций, мы игнорируем константу 2 и получаем сложность O(n).
Пример:
```
// Сложность: O(2n)
function printTwice(arr) {
    for (let i = 0; i < 2 * arr.length; i++) {
        console.log(arr[i]);
    }
}
```

## Структуры данных

1) Массив (Array) - хранит элементы в последовательности. Доступ к элементу за O(1). Вставка/удаление в начало/середину массива — O(n).
```
const arr = [1, 2, 3];
```

2) Хеш-таблица (Hash Table) - хранит пары ключ-значение. Доступ за O(1).
```
const map = {};
map['key'] = 'value';
```

3) Стек (Stack) - LIFO (Last In, First Out).
Операции: push, pop.
```
const stack = [];
stack.push(1); // Добавить
stack.pop();   // Удалить
```

4) Очередь (Queue) - FIFO (First In, First Out).
Операции: enqueue, dequeue.
```
const queue = [];
queue.push(1); // Добавить
queue.shift(); // Удалить
```

5) Связанный список (Linked List) - Узлы хранят значение и ссылку на следующий узел. Вставка/удаление за O(1) (если знаете узел).
```
class Node {
  constructor(value) {
  this.value = value;
  this.next = null;
  }
}
```

6) Дерево (Tree) - Иерархическая структура с корнем и дочерними узлами.
Пример: бинарное дерево.
```
class TreeNode {
  constructor(value) {
  this.value = value;
  this.left = null;
  this.right = null;
  }
}
```

7) Граф (Graph) - Множество вершин и ребер.
Пример: социальная сеть.
```
const graph = {
  A: ['B', 'C'],
  B: ['A', 'D'],
  C: ['A'],
  D: ['B']
};
```

8) Map (new Map()) - отличительная особеннность структуры данных Map это то, что в Map ключем может быть все что угодно. Сохраняется порядок при добавлении.
Методы: set - добавить элемент, get - получить элемент, has - есть ли ключ, delete - удаляем по ключу, clear - очищаем все, size - узнать размер.
Пример:
```
const map = new Map();
function best(){console.log("this function the best")};
const array = [1,2,3,4,5,6];
map.set(best, 'interesting function');
map.set(array, 'interesting array');
map.get(array); // 'interesting array'
map.get(best) // 'interesting function'
```

10) Set (new Set()) - отличительной чертой структуры данных Set является то, что Set всегда хранит уникальные значения. Сохраняется порядок при добавлении.
Методы: add - добавили элемент, delete - удалили элемент, has - проверили что элемент есть, clear - почистили, size - узнать размер.
Пример:
```
const vault = new Set();
vault.add(3)
vault.add(2)
vault.add(3)
console.log(vault) // Set [ 3, 2 ]
```

## Алгоритмы

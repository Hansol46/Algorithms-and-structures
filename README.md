# Теория алгоритмов

## Понятия

Сложность алгоритма в теории алгоритмов описывается с помощью формулы:
_O(n)_, где _n_ - это кол-во операций, за который этот алгоритм приходит к нужному результату.(всегда рассматривается наихудший результат)

Примеры функций которыми чаще всего описывается сложность алгоритма:

1. _O(Log2n)_

2. _O(n)_

3. _O(n\*log2n)_

4. _O(n\*n)_

5. _O(n!)_ - очень долго

## Задачи

### Линейный поиск:

Линейный поиск - начает поиск с первого элемента и последовательно сравниваем с тем который ищем.

Задание: Есть массив _array = [7,6,1,4,0,2,9,5,8,3]_, необходимо найти определенный элемент, в нашем случае _3_

Сложность алгоритма: _O(n)_,
где _n_ - количество элементов в массиве.
(для массива из 10 элементов будет 10 операций, для массива из 1000 элементов - 1000 операций)

### Бинарный поиск

_примечание_ - (работает только при условии, что массив отсортирован по порядку)

Бинарный поиск - поиск осуществляется путем разделение массива на пополам, далее происходит проверка числа на которое мы попали при разделении,
после мы проверяем больше или меньше наше искомое число, и делим следующую половину массива.

Задание: Есть массив _array = [0,1,2,3,4,5,6,7,8,9]_, необходимо найти определенный элемент, в нашем случае _7_

Сложность алгоритма: _O(log2n)_, 
мы поделим массив пополам попадем на 4, поймем что 7 больше 4, пойдем искать в ту сторону, поделим большую половину еще раз пополам и попадем на 7.

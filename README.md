# Теория алгоритмов

## Понятия

Сложность алгоритма в теории алгоритмов описывается с помощью формулы:_O(n)_, 
где _n_ - это кол-во операций, за который этот алгоритм приходит к нужному результату, всегда рассматривается наихудший сценарий.
Ссылка на полезнеёшую статью: https://habr.com/ru/articles/782608/

### Виды сложностей

1. _О(1)_ - константная сложность
При константной сложности вне зависимости от размера входных данных (n), время выполнения алгоритма остается постоянным и не зависит от объема данных.
Пример:
```
function getLastElement(arr) {
  return arr[arr.length - 1 ]
}
function addToArray(arr, el) {
  return arr.push(el);
}
```

2. _O(n)_ - линейная сложность
Оценка временной сложности O(n) означает, что время выполнения алгоритма растет линейно с увеличением размера входных данных.
пример:
```
function findMax(arr) {
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}
```

3. _O(logn)_ - логарифмическая сложность.
Алгоритм становится медленнее, но не линейно, а медленнее в соответствии с логарифмической функцией.
Пример: Бинарный поиск. В этом алгоритме на каждом шаге половина данных отсекается, и поиск продолжается в оставшейся половине. Это означает, что при увеличении размера входных данных вдвое, бинарный поиск требует всего одного дополнительного шага.
```
function binarySearch(arr, target) {
	let left = 0;
	let right = arr.length - 1;
  while (left &lt;= right) {
	  let mid = Math.floor((left + right) / 2);
	  if (arr[mid] === target) return mid; 
	  if (arr[mid] &lt; target) {
      left = mid + 1;
	  } else {
      right = mid - 1; // искать в левой половине
	  }
  }
  return -1; // элемент не найден
}
```

4. _O(n^2)_ - квадратичная
Время выполнения растет пропорционально квадрату размера входных данных
Пример: Это часто возникает в алгоритмах с вложенными циклами, когда каждый элемент первого списка обрабатывается с каждым элементом второго списка.

5. _O(n^3)_ - кубическая
Время выполнения алгоритма увеличивается кубически по размеру входных данных.
Пример: опять же по аналогии с квадратичной, 3 вложенных цикла.


6. _O(2^n)_ - экспоненциальная
Время выполнения алгоритма увеличивается экспоненциально по мере увеличения размера входных данных. Это часто встречается в алгоритмах, которые решают проблемы методом "разделяй и властвуй" или используют рекурсию без оптимизации.
Пример:
```
function fibonacci(n) {
	if (n === 1 || n === 2) return 1; 
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

7. O(n!) - факториальная сложность
Время выполнения алгоритма растет пропорционально факториалу размера входных данных. Факториал - это произведение всех положительных целых чисел от 1 до n.
Пример алгоритма с факториальной сложностью может быть перебор всех перестановок элементов массива.

### Дополнение
Игнорирование констант. В данном случае, даже если у нас есть 2n операций, мы игнорируем константу 2 и получаем сложность O(n).
Пример:
```
// Сложность: O(2n)
function printTwice(arr) {
    for (let i = 0; i < 2 * arr.length; i++) {
        console.log(arr[i]);
    }
}
```
